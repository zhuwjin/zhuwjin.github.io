[{"content":"〇、引言 在Linux下使用C语言非常的简单，只需要安装GCC或者Clang编译器就可以了\n而在Windows下使用C语言，可以有多种方案，这篇文章里将介绍2种方法，分别是mingw64，和msvc。\nmingw64呢，是可以在windows下运行一些linux下的应用，如GCC等。而且编译出来的程序也可以在Windwos下运行。\nmsvc就是windows下原生的编译器了，但是安装msvc需要安装vs，需要大量的磁盘空间。而mingw64需要的空间是比较小的。\n一、在Windows下安装mingw64以使用GCC 1.1、下载msys2 msys2官网\n1.2、安装msys2 选择好你的安装路径，一路下一步就行了\n1.3、配置msys2的源 在北外的镜像站里有配置说明\n1.4、安装GCC和其他库文件 pacman -S --needed base-devel mingw-w64-x86_64-toolchain 然后一路回车，等待下载安装完成\n1.5、修改环境变量 找到msys2的安装目录里的这两个目录。\n在搜索里搜索环境变量可以快速打开编辑环境变量的窗口。\n选择用户的环境变量，然后选中Path，然后点编辑\n将两个目录添加到环境变量里。\n1.6、检测是否安装完成 打开powershell，输入gcc -v看看是否有输出。\n1.7、在VSCode里编写代码 1.7.0、VSCode的安装 在官网下载安装就行，一路下一步。\n1.7.1、安装插件 如果你需要中文界面，可以在插件商店搜索Chinese，下载最多的那个，安装它\n然后安装C/C++插件\n1.7.2、用C编写一个程序 按照国际惯例，写一个Hello World!试试。\n建议在一个空的文件夹里写，比如我的在C:\\User\\Jin\\Documents\\Code\\C\\Hello里。\n这里的C就是用C写的代码，Hello是一个项目。\n#include \u0026lt;stdio.h\u0026gt; int mian() { printf(\u0026#34;Hello world!\\n\u0026#34;); return 0; } 然后点击右边的那个三角形编译运行代码。\n在弹出的窗口里选择gcc(其他你也没得选)。\n然后在终端里就能看见输出的Hello world!了。\n接下来试试调试程序，在代码的左边点一下，会出现一个红色的小点，叫断点，程序执行到这会中断。\n在点一下右边的三角形，运行程序。然后就可以很方便的看到变量当前的值了。\n1.7.3、用C++编写一个程序 和C一样，在一个空白的文件里创建一个项目。然后写一个程序。\n然后点击三角形运行。\n在弹出的窗口里选g++。\n然后想要的结果就出来了\n1.8、在CLion里编写代码 CLion和PyCharm、IDEA一样，都是jetbrains公司出品的软件，CLion使用起来比较方便，就是内存占用比较大，而且需要许可证，不过可以使用学生账户，我目前就是使用的学生许可证的CLion。\nCLion在官网就可以下载，如果还使用他们公司的其他产品，可以下载一个jetbrains ToolBox，来管理他们家的app\n1.8.1、下载安装CLion 打开安装包，然后一路下一步，如果需要桌面图标可以把下面的选项勾选了。\n1.8.2、运行CLion并配置许可证 打开CLion，然后一路下一步。\n可以申请学生账户，也可以注册个帐号来试用30天。\n如果需要中文界面，可以安装这个插件。安装完会提示重新打开CLion。\n重新打开后就是中文界面了。\n1.8.3、在CLion里创建一个C项目 在主页选择新建项目，然后选择C可执行文件，输入项目的目录名称，然后创建。\n创建完成后会弹出一个向导窗口，他会自动检测到我们之前安装的mingw，等待它检测完成，然后点击确定。\nCLion在创建一个项目后，会自动给我们写一个Hello World程序。然后看见那个可爱的绿色的三角形了么，点击它。\n程序就运行出来了。\n二、在Windows上安装Visual Studio来使用C语言 2.1、安装Visual Studio 2022 在官网下载Visual Studio Installer\n在Visual Studio Installer中选择社区版进行安装。\n然后在工作负载里选择使用C++的桌面开发。如果要修改安装位置，就修改一下，可以只改盘符，比如C改成D，其他不动。\n然后注意他要10G的空间。然后点安装就行了。\n慢慢的等待它安装完成。\n安装完成后重启电脑。\n2.2、使用Visual Studio 2022创建C项目 在开始菜单找到Visual Studio 2022，然后打开它。\n然后配置Visual Studio 2022，登录账户的以后再说，其他的一路下一步。\n然后点创建新项目。\n然后选择控制台应用。\n然后随便取个名字，点创建。\n然后它也会给你一个写好的Hello world。我们先运行试试。点击那个绿色的实心的三角形。\n就会弹出一个控制台，并显示Hello World!了。\n接下来我们试试C语言的。\n把原来的cpp的文件右键删除。\n然后在源文件里添加新建项。\n在下面的名称里写上以.c为后缀的文件。然后点击添加。\n然后在里面写上如下内容。点击本地Windows调试器。\n","permalink":"https://jinjiang.life/posts/c-00/","summary":"〇、引言 在Linux下使用C语言非常的简单，只需要安装GCC或者Clang编译器就可以了\n而在Windows下使用C语言，可以有多种方案，这篇文章里将介绍2种方法，分别是mingw64，和msvc。\nmingw64呢，是可以在windows下运行一些linux下的应用，如GCC等。而且编译出来的程序也可以在Windwos下运行。\nmsvc就是windows下原生的编译器了，但是安装msvc需要安装vs，需要大量的磁盘空间。而mingw64需要的空间是比较小的。\n一、在Windows下安装mingw64以使用GCC 1.1、下载msys2 msys2官网\n1.2、安装msys2 选择好你的安装路径，一路下一步就行了\n1.3、配置msys2的源 在北外的镜像站里有配置说明\n1.4、安装GCC和其他库文件 pacman -S --needed base-devel mingw-w64-x86_64-toolchain 然后一路回车，等待下载安装完成\n1.5、修改环境变量 找到msys2的安装目录里的这两个目录。\n在搜索里搜索环境变量可以快速打开编辑环境变量的窗口。\n选择用户的环境变量，然后选中Path，然后点编辑\n将两个目录添加到环境变量里。\n1.6、检测是否安装完成 打开powershell，输入gcc -v看看是否有输出。\n1.7、在VSCode里编写代码 1.7.0、VSCode的安装 在官网下载安装就行，一路下一步。\n1.7.1、安装插件 如果你需要中文界面，可以在插件商店搜索Chinese，下载最多的那个，安装它\n然后安装C/C++插件\n1.7.2、用C编写一个程序 按照国际惯例，写一个Hello World!试试。\n建议在一个空的文件夹里写，比如我的在C:\\User\\Jin\\Documents\\Code\\C\\Hello里。\n这里的C就是用C写的代码，Hello是一个项目。\n#include \u0026lt;stdio.h\u0026gt; int mian() { printf(\u0026#34;Hello world!\\n\u0026#34;); return 0; } 然后点击右边的那个三角形编译运行代码。\n在弹出的窗口里选择gcc(其他你也没得选)。\n然后在终端里就能看见输出的Hello world!了。\n接下来试试调试程序，在代码的左边点一下，会出现一个红色的小点，叫断点，程序执行到这会中断。\n在点一下右边的三角形，运行程序。然后就可以很方便的看到变量当前的值了。\n1.7.3、用C++编写一个程序 和C一样，在一个空白的文件里创建一个项目。然后写一个程序。\n然后点击三角形运行。\n在弹出的窗口里选g++。\n然后想要的结果就出来了\n1.8、在CLion里编写代码 CLion和PyCharm、IDEA一样，都是jetbrains公司出品的软件，CLion使用起来比较方便，就是内存占用比较大，而且需要许可证，不过可以使用学生账户，我目前就是使用的学生许可证的CLion。\nCLion在官网就可以下载，如果还使用他们公司的其他产品，可以下载一个jetbrains ToolBox，来管理他们家的app\n1.8.1、下载安装CLion 打开安装包，然后一路下一步，如果需要桌面图标可以把下面的选项勾选了。\n1.8.2、运行CLion并配置许可证 打开CLion，然后一路下一步。\n可以申请学生账户，也可以注册个帐号来试用30天。\n如果需要中文界面，可以安装这个插件。安装完会提示重新打开CLion。\n重新打开后就是中文界面了。","title":"在Windows上使用C语言"},{"content":"DOSBOX的使用 右键DOSBOX点击打开文件所在位置\n找到文件夹里的DOSBox 0.7.4-3 Options，双击打开或右键点打开\n然后就会出现记事本打开一个文本文件\n找到你MASM放到哪个文件夹里的\n复制这个地址，然后修改刚刚的文本文件 在最下面添加两行\nmount x 你的MASM路径 set PATH=%PATH%;x:\\; 保存，然后打开DOSBOX看看效果 就可以直接使用masm命令了\n接下来把工作区弄好，打开你写汇编代码的地方，复制路径\n然后再打开刚刚的DOSBox 0.7.4-3 Options\n添加这两行\nmount c 你的工作路径 c: 保存退出\n然后打开DOSBOX，它就会自动转到你的工作目录里了\n如果你使用了我的代码，在DOSBOX里运行build.bat，就可以将菜单程序编译了\n然后运行菜单程序，输入MENU.EXE，菜单就出来啦\n随便输一个数据显示出来\n代码压缩包\n代码 extrn input:far, edit:far, sort:far, output:far disp macro x,length,color ;用来显示的宏，x为横坐标偏移量，length为字符串长度，color为颜色 mov ax,1301h mov bx,color mov cx,length mov dh,yy mov dl,x mov bp,addr int 10h ;10号BIOS调用 endm data segment l0 db \u0026#39; MENU \u0026#39; l1 db \u0026#39;=====================\u0026#39; l2 db \u0026#39;| INPUT GRADE |\u0026#39; l3 db \u0026#39;| EDIT GRADE |\u0026#39; l4 db \u0026#39;| SORT GRADE |\u0026#39; l5 db \u0026#39;| OUTPUT GRADE |\u0026#39; l6 db \u0026#39;| EXIT |\u0026#39; l7 db \u0026#39;=====================\u0026#39; ;l0-l6存要显示的菜单字符串 LL EQU $-l7 ;一个菜单字符串的长度 XX equ (80-ll)/2 ;xx输出是横向偏移量，让菜单显示在屏幕中间 yy db ? ;行号（相对屏幕第一行） nn dw 1 ;行号（相对l0行） tab dw ?,l2,l3,l4,l5,l6 ;记录字符串的偏移地址 addr dw ? ;字符串偏移量 grade db 50 dup(5 dup(?), 10 dup(?), 3 dup (?)) count db 0 data ends stack segment para stack \u0026#39;stack\u0026#39; ;堆栈段 db 256 dup(0) stack ends code segment assume cs:code,ss:stack,ds:data start: mov ax, data mov ds, ax mov es, ax last1: mov ax, 3 int 10h ;设置显示模式 mov yy, 8 ;让屏幕上方有8个空行 mov addr, offset l0 ;将偏移量变量设为l0，准备打印l0行的内容 last2: disp xx, ll, 0fh ;先以无颜色打印所有行 add addr, ll ; inc yy ; cmp yy, 16 ; jl last2 ; mov nn, 1 ;将当前行号设为1，准备将第一行上色 call compute ;计算需要刷新的字符串的偏移量 disp xx+4, ll-8, 51h ;上色刷新,+4表示前面4个字符不刷新,-8表示后面8个字符不刷新,51为颜色编号 scan: mov ah, 1 int 16h ;扫描是否键盘有输入 jz scan ;没有输入就继续扫描，有则判断并处理 mov ah, 0 int 16h ;获取键盘输入的ascii码 cmp ah, 80 ;80为下键 je down ;转到下键的处理代码 cmp ah, 72 ;72为上键 je up ;转到上键的处理代码 cmp al, 0dh ;0dh为回车 je enter jmp scan down: ;下键的处理代码 cmp nn, 5 ;行号为5则到底了，不处理 je scan call compute ;计算当前行需要刷新的字符串的偏移量 disp xx+4, ll-8, 0fh ;将当前的一行颜色复原 inc nn ;移动到下一行 call compute disp xx+4, ll-8, 51h ;将颜色改变表示预选中这一行 jmp scan ;返回继续扫描键盘接下来的操作 up: cmp nn, 1 je scan call compute disp xx+4, ll-8, 0fh dec nn ;和下键的处理代码一样，只是需要判断上界和向上移动 call compute disp xx+4, ll-8, 51h jmp scan enter: cmp nn, 1 ;nn等于1，表示光标在第一行，则执行成绩录入功能 jne next2 xor ax, ax ;清空ax里的内容 ;接下来求下一个要插入数据的地址 ; ：grade的首地址 + 已经插入的个数(count) * 数据长度(18) mov al, count ;将已经录入的成绩个数移入al mov ah, 18 ;将乘数移入ah准备作乘法 mul ah ;乘法指令， ax \u0026lt;-- ah * al mov dx, offset grade ;将grade的首地址放入dx add dx, ax ;加上ax中的内容 mov bl, count inc count ;将个数 + 1，这行代码放在call上或下面不影响，因为input中不用count变量了，并且count只能成功 call input ;调用input，input的入口参数是dx next2: cmp nn, 2 ;成绩修改 jne next3 mov dx, offset grade mov bl, count call edit next3: cmp nn, 3 ;成绩排序 jne next4 mov dx, offset grade mov bl, count call sort next4: cmp nn, 4 ;成绩输出 jne next5 mov dx, offset grade mov bl, count call output next5: cmp nn, 5 ;退出 je exit jmp last1 exit: mov ax, 3 int 10h mov ax,4c00h int 21h compute proc near ;计算需要刷新的字符串的偏移量 mov di,nn add di,di ;因为tab存的是dw类型所以要乘以2 mov ax,tab[di] ;找到当前行的字符串偏移量 add ax,4 ;因为前面有四个其他字符不用刷新上色，所以加4 mov addr,ax ;将计算出的偏移量存起来 mov al,byte ptr nn add al,9 mov yy,al ;相对l0的行数+9位相对屏幕的行数 ret compute endp code ends end start public input data segment input_info0 db \u0026#39;input student id(length:5):\u0026#39;, \u0026#39;$\u0026#39; input_info1 db 0dh,0ah,\u0026#39;input student name(length:10):\u0026#39;, \u0026#39;$\u0026#39; input_info2 db 0dh,0ah,\u0026#39;input student grade(0-100):\u0026#39;, \u0026#39;$\u0026#39; buffer0 db 6 ;输入缓冲区，用来学生id信息，长度6是因为后面需要留一个byte的空间 db ? db 6 dup (?) buffer1 db 11 ;输入缓冲区，用来学生name信息 db ? db 11 dup (?) buffer2 db 4 ;输入缓冲区，用来学生grade信息 db ? db 4 dup (?) data ends code segment input proc far ;入口参数dx：要插入的数据的内存单元的偏移地址 assume cs:code,ds:data push ds ;保存寄存器中的内容，也就是主程序的数据段基址，子程序返回前需还原 mov ax, data ;将子程序的数据段基址移入ds mov ds, ax mov ax, 3 int 10h ;清空界面 push dx ;因为下面要用到dx，所以现将dx保存在栈中 mov dx, offset input_info0 ;输出提示信息 mov ah, 9 int 21h mov dx, offset buffer0 ;输入学生id到buffer0 mov ah, 0ah ;此调用在课本137页有详细说明 int 21h pop dx ;从栈中恢复dx lea si, buffer0 ;将buffer用字符串传送指令传送到主程序的grade中 add si, 2 ;buffer0中前两个byte为记录详细，不需要传送 mov di, dx ;将目的地址偏移量传送到di中 mov cx, 5 ;传送byte个数 rep movsb ;es:di \u0026lt;-- ds:si; di++, si++；课本86-87页 ;因为子程序初始化的时候没改es，所以es中的地址还是主程序数据段的地址 ;这样从ds--\u0026gt;es就能将子程序中的数据传送到主程序 push dx ;因为下面要用到dx，所以现将dx保存在栈中 mov dx, offset input_info1 ;输出提示信息 mov ah, 9 int 21h mov dx, offset buffer1 ;输入学生姓名 mov ah, 0ah int 21h pop dx ;从栈中恢复dx lea si, buffer1 ;传送到主程序 add si, 2 mov di, dx add di, 5 mov cx, 10 rep movsb push dx mov dx, offset input_info2 ;输出提示信息 mov ah, 9 int 21h mov dx, offset buffer2 ;输入成绩 mov ah, 0ah int 21h pop dx lea si, buffer2 ;传送 add si, 2 mov di, dx add di, 15 mov cx, 3 rep movsb pop ds ;恢复原来的ds ret input endp code ends end public edit data segment input_info0 db \u0026#39;input student id(length:5):\u0026#39;, \u0026#39;$\u0026#39; input_info1 db 0dh,0ah,\u0026#39;input new grade(0-100):\u0026#39;, \u0026#39;$\u0026#39; tag db ? addr dw ? buffer0 db 6 db ? db 6 dup (?) buffer1 db 4 db ? db 4 dup (?) data ends code segment edit proc far ;入口参数dx：grade的起始地址 assume cs:code,ds:data push ds ;保存寄存器 mov ax, data mov ds, ax mov addr, dx ;将起始地址保存在addr中 mov tag, 1 ;初始化tag为 1 mov ax, 3 int 10h ;清屏 mov dx, offset input_info0 ;输出提示信息 mov ah, 9 int 21h mov dx, offset buffer0 ;输入学号 mov ah, 0ah int 21h call search ;调用search，搜索输入的学号的位置，入口参数为addr，出口参数为dx，和tag cmp tag, 1 ;判断search的查找结果，1表示找到了，且dx中存放这个学号的起始地址 jne exit1 ;没找到，直接退出 push dx ;保存dx，因为接下来要修改 mov dx, offset input_info1 ;输出提示信息 mov ah, 9 int 21h mov dx, offset buffer1 ;输入成绩 mov ah, 0ah int 21h pop dx ;恢复dx lea si, buffer1 ;字符串的传送操作，和input中的一样，把新成绩传送到主程序中 add si, 2 mov di, dx add di, 15 mov cx, 3 rep movsb exit1: pop ds ret edit endp search proc near ;入口参数addr，buffer0 xor cx, cx ;清空cx mov cl, bl ;将成绩个数移动到cl中，来控制循环次数 cmp cx, 0 ;个数为0，直接查找失败 je fail mov di, addr ;将grade首地址移动到mov中 mov bx, di ;保存一下di中的内容 loop1: push cx ;保存一下cx mov si, offset buffer0 ;si存源操作数偏移地址 add si, 2 ;前面2个记录信息，不需要比较 mov cx, 5 ;比较的长度 repz cmpsb ;比较 ds:si ---- es:di ;这里ds是子程序的数据段的段基址，es因为没改，所以是主程序的数据段的段基址，所以可以实现 ;从子程序向主程序传送数据 pop cx ;恢复cx jne next ;如果两个字符串不相等，比较下一个人的成绩 jmp exit ;如果相等，查找结束，bx中就是这个成绩记录的首地址 next: add bx, 18 ;下一个成绩的首地址为当前的 + 18 mov di, bx ;把地址也写到di中，开始下一轮循环 loop loop1 fail: ;如果循环结束了都没找到，这查找失败 mov tag, 0 exit: mov dx, bx ;出口参数dx ret search endp code ends end public sort code segment sort proc far assume cs:code push dx xor cx, cx mov cl, bl cmp cx, 0 je exit1 dec cx cmp cx, 0 je exit1 loop1: mov di, cx mov bp, sp mov ax, [bp] loop2: mov bx, ax call comp cmp bl, 1 je continue mov si, ax call swap continue: add ax, 18 loop loop2 mov cx, di loop loop1 exit1: pop dx ret sort endp str2int proc near ;入口参数dx push ax push bx push si add dx, 15 mov si, dx mov al, [si] cmp al, 0dh je zero sub al, 30h mov bl, [si + 1] cmp bl, 0dh je next mov ah, 10 mul ah add al, bl sub al, 30h mov bl, [si + 2] cmp bl, 0dh je next mov al, 100 next: mov dl, al jmp exit zero: mov dl, 0 jmp exit exit: pop si pop bx pop ax ;出口参数dl ret str2int endp comp proc near ;入口参数bx push ax mov dx, bx call str2int mov ah, dl mov dx, bx add dx, 18 call str2int mov al, dl mov bl, 1 cmp ah, al ja next1 mov bl, 0 next1: pop ax ;出口参数bl，大于等于为1，否则为0 ret comp endp swap proc near ;入口参数si push ax push cx mov cx, 18 swap1: push cx mov al, [si] xchg al, [si + 18] mov [si], al pop cx inc si loop swap1 pop cx pop ax ret swap endp code ends end public output disp macro x,y,length,color ;用来显示的宏，x为横坐标偏移量，length为字符串长度，color为颜色 mov ax,1301h mov bx,color mov cx,length mov dh,y mov dl,x mov bp,addr int 10h ;10号BIOS调用 endm data segment l0 db \u0026#39; ID NAME GRADE \u0026#39; l1 db \u0026#39;+--------------------------+\u0026#39; l2 db \u0026#39;| | | |\u0026#39; ll equ $-l2 xx equ (80-ll)/2 yy db ? addr dw ? grades dw ? count db ? nn db 0 ;行号（相对l0行） data ends code segment output proc far assume cs:code,ds:data push ds;保存寄存器 push es mov ax, data mov ds, ax mov es, ax mov grades, dx mov count, bl mov ax, 3 int 10h mov addr, offset l0 disp xx, 6 ,ll, 0fh mov addr, offset l1 disp xx, 7 ,ll, 0fh mov addr, offset l2 mov cx, 10 mov yy, 8 print_frame: push cx disp xx, yy ,ll, 0fh pop cx inc yy loop print_frame mov addr, offset l1 disp xx, 18 ,ll, 0fh jmp print_grades scan1: mov ah, 1 int 16h ;扫描是否键盘有输入 jz scan1 mov ah, 0 int 16h cmp ah, 80 ;80为下键 je down ;转到下键的处理代码 cmp ah, 72 ;72为上键 je up ;转到上键的处理代码 cmp al, 113 je exit jmp scan1 down: mov al, nn add al, 10 cmp al, count jae scan1 inc nn jmp print_grades up: mov al, nn cmp al, 0 jbe scan1 dec nn jmp print_grades exit: pop es pop ds ret print_grades: xor cx, cx mov cl, 10 mov al, count sub al, nn cmp cl, al jb next1 mov cl, al next1: cmp cx, 0 jbe scan1 pop es mov yy, 8 mov ax, grades mov addr, ax xor ax, ax mov al, nn mov ah, 18 mul ah add addr, ax print_cow: push cx push addr push es mov ax, ds mov es, ax mov addr, offset l2 disp xx, yy ,ll, 0fh pop es pop addr disp xx+2, yy, 5, 0fh add addr, 5 jmp gateway2 gateway1: jmp print_cow gateway2: disp xx+10, yy, 10, 0fh add addr, 10 disp xx+23, yy, 3, 0fh add addr, 3 inc yy pop cx dec cx cmp cx, 0 ja gateway1 push es jmp scan1 output endp code ends end ","permalink":"https://jinjiang.life/posts/asm-01/","summary":"DOSBOX的使用 右键DOSBOX点击打开文件所在位置\n找到文件夹里的DOSBox 0.7.4-3 Options，双击打开或右键点打开\n然后就会出现记事本打开一个文本文件\n找到你MASM放到哪个文件夹里的\n复制这个地址，然后修改刚刚的文本文件 在最下面添加两行\nmount x 你的MASM路径 set PATH=%PATH%;x:\\; 保存，然后打开DOSBOX看看效果 就可以直接使用masm命令了\n接下来把工作区弄好，打开你写汇编代码的地方，复制路径\n然后再打开刚刚的DOSBox 0.7.4-3 Options\n添加这两行\nmount c 你的工作路径 c: 保存退出\n然后打开DOSBOX，它就会自动转到你的工作目录里了\n如果你使用了我的代码，在DOSBOX里运行build.bat，就可以将菜单程序编译了\n然后运行菜单程序，输入MENU.EXE，菜单就出来啦\n随便输一个数据显示出来\n代码压缩包\n代码 extrn input:far, edit:far, sort:far, output:far disp macro x,length,color ;用来显示的宏，x为横坐标偏移量，length为字符串长度，color为颜色 mov ax,1301h mov bx,color mov cx,length mov dh,yy mov dl,x mov bp,addr int 10h ;10号BIOS调用 endm data segment l0 db \u0026#39; MENU \u0026#39; l1 db \u0026#39;=====================\u0026#39; l2 db \u0026#39;| INPUT GRADE |\u0026#39; l3 db \u0026#39;| EDIT GRADE |\u0026#39; l4 db \u0026#39;| SORT GRADE |\u0026#39; l5 db \u0026#39;| OUTPUT GRADE |\u0026#39; l6 db \u0026#39;| EXIT |\u0026#39; l7 db \u0026#39;=====================\u0026#39; ;l0-l6存要显示的菜单字符串 LL EQU $-l7 ;一个菜单字符串的长度 XX equ (80-ll)/2 ;xx输出是横向偏移量，让菜单显示在屏幕中间 yy db ?","title":"用汇编(MASM)写的小程序"},{"content":"〇、SpringMVC 一、Hello SpringMVC 1.0、创建项目 创建一个maven项目，并在pom.xml中进行配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;life.jinjiang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;LearnSpringMVC\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--定义打包方式为war包--\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;!--使用spring版本为5.3.15--\u0026gt; \u0026lt;spring.version\u0026gt;5.3.15\u0026lt;/spring.version\u0026gt; \u0026lt;thymeleaf.version\u0026gt;3.0.14.RELEASE\u0026lt;/thymeleaf.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${thymeleaf.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--使用war的打包插件--\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 1.1、配置web.xml 在main目录下创建一个webapp/WEB-INF目录，并在其中创建web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_0.xsd\u0026#34; version=\u0026#34;3.0\u0026#34;\u0026gt; \u0026lt;!--配置servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springMVC.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--配置启动时创建类--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--配置映射--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 1.2、配置Bean \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;life.jinjiang.controller\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.thymeleaf.spring5.view.ThymeleafViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;order\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;templateEngine\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.SpringTemplateEngine\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;templateResolver\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/templates/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.html\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;templateMode\u0026#34; value=\u0026#34;HTML5\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.3、创建一个controller package life.jinjiang.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class HelloController { @GetMapping(\u0026#34;/hello\u0026#34;) public String hello() { return \u0026#34;hello\u0026#34;; } } 在WEB-INF中创建一个templates目录并在其中创建一个hello.html文件\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello SpringMVC\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello SpringMVC\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1.4、编译打包项目 使用命令行目录\nmvn package 或者用idea里的package\n1.5、配置tomcat服务器 将打包好的war包放入tomcat目录里得webapps目录中\n修改tomcat目录里conf/server.xml文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Server port=\u0026#34;8005\u0026#34; shutdown=\u0026#34;SHUTDOWN\u0026#34;\u0026gt; \u0026lt;Listener className=\u0026#34;org.apache.catalina.startup.VersionLoggerListener\u0026#34; /\u0026gt; \u0026lt;Listener className=\u0026#34;org.apache.catalina.core.AprLifecycleListener\u0026#34; SSLEngine=\u0026#34;on\u0026#34; /\u0026gt; \u0026lt;Listener className=\u0026#34;org.apache.catalina.core.JreMemoryLeakPreventionListener\u0026#34; /\u0026gt; \u0026lt;Listener className=\u0026#34;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener\u0026#34; /\u0026gt; \u0026lt;Listener className=\u0026#34;org.apache.catalina.core.ThreadLocalLeakPreventionListener\u0026#34; /\u0026gt; \u0026lt;GlobalNamingResources\u0026gt; \u0026lt;Resource name=\u0026#34;UserDatabase\u0026#34; auth=\u0026#34;Container\u0026#34; type=\u0026#34;org.apache.catalina.UserDatabase\u0026#34; description=\u0026#34;User database that can be updated and saved\u0026#34; factory=\u0026#34;org.apache.catalina.users.MemoryUserDatabaseFactory\u0026#34; pathname=\u0026#34;conf/tomcat-users.xml\u0026#34; /\u0026gt; \u0026lt;/GlobalNamingResources\u0026gt; \u0026lt;Service name=\u0026#34;Catalina\u0026#34;\u0026gt; \u0026lt;Connector port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443\u0026#34; /\u0026gt; \u0026lt;Engine name=\u0026#34;Catalina\u0026#34; defaultHost=\u0026#34;localhost\u0026#34;\u0026gt; \u0026lt;Realm className=\u0026#34;org.apache.catalina.realm.LockOutRealm\u0026#34;\u0026gt; \u0026lt;Realm className=\u0026#34;org.apache.catalina.realm.UserDatabaseRealm\u0026#34; resourceName=\u0026#34;UserDatabase\u0026#34;/\u0026gt; \u0026lt;/Realm\u0026gt; \u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34; unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Valve className=\u0026#34;org.apache.catalina.valves.AccessLogValve\u0026#34; directory=\u0026#34;logs\u0026#34; prefix=\u0026#34;localhost_access_log\u0026#34; suffix=\u0026#34;.txt\u0026#34; pattern=\u0026#34;%h %l %u %t \u0026amp;quot;%r\u0026amp;quot; %s %b\u0026#34; /\u0026gt; \u0026lt;!--在这里添加Context--\u0026gt; \u0026lt;Context path=\u0026#34;/\u0026#34; reloadable=\u0026#34;true\u0026#34; docBase=\u0026#34;LearnSpringMVC-1.0-SNAPSHOT\u0026#34; /\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;/Engine\u0026gt; \u0026lt;/Service\u0026gt; \u0026lt;/Server\u0026gt; 1.6、运行tomcat服务器 执行下面命令行命令\nbin/start.sh 访问\ncurl localhost:8080/hello ","permalink":"https://jinjiang.life/posts/java-springmvc/","summary":"〇、SpringMVC 一、Hello SpringMVC 1.0、创建项目 创建一个maven项目，并在pom.xml中进行配置\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;life.jinjiang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;LearnSpringMVC\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--定义打包方式为war包--\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;!--使用spring版本为5.3.15--\u0026gt; \u0026lt;spring.version\u0026gt;5.3.15\u0026lt;/spring.version\u0026gt; \u0026lt;thymeleaf.version\u0026gt;3.0.14.RELEASE\u0026lt;/thymeleaf.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${thymeleaf.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--使用war的打包插件--\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-war-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 1.1、配置web.xml 在main目录下创建一个webapp/WEB-INF目录，并在其中创建web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_0.xsd\u0026#34; version=\u0026#34;3.0\u0026#34;\u0026gt; \u0026lt;!--配置servlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;SpringMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springMVC.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--配置启动时创建类--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!","title":"Java SpringMVC"},{"content":"〇、AOP 面向切面编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。不修改原代码添加新功能。\n一、AOP底层原理 AOP底层使用动态代理。\n1、JDK动态代理 public interface Student { void say_hello(); int add(int a, int b); } public class StudentImpl implements Student{ @Override public void say_hello() { System.out.println(\u0026#34;Hello\u0026#34;); } @Override public int add(int a, int b) { return a + b; } } public class MainApplication { public static void main(String[] args) { Student student = new StudentImpl(); Class[] interfaces = {Student.class}; Student student1 = (Student) Proxy.newProxyInstance(MainApplication.class.getClassLoader(), interfaces, new MyStudentProxy(student)); student1.add(1, 2); } } class MyStudentProxy implements InvocationHandler { private Object obj; public MyStudentProxy(Object obj) { this.obj = obj; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;aaaaa\u0026#34;); Object res = method.invoke(obj, args); System.out.println(\u0026#34;bbbbb\u0026#34;); System.out.println(res); return res; } } aaaaa bbbbb 3 ","permalink":"https://jinjiang.life/posts/spring-aop/","summary":"〇、AOP 面向切面编程。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。不修改原代码添加新功能。\n一、AOP底层原理 AOP底层使用动态代理。\n1、JDK动态代理 public interface Student { void say_hello(); int add(int a, int b); } public class StudentImpl implements Student{ @Override public void say_hello() { System.out.println(\u0026#34;Hello\u0026#34;); } @Override public int add(int a, int b) { return a + b; } } public class MainApplication { public static void main(String[] args) { Student student = new StudentImpl(); Class[] interfaces = {Student.class}; Student student1 = (Student) Proxy.newProxyInstance(MainApplication.class.getClassLoader(), interfaces, new MyStudentProxy(student)); student1.","title":"Spring Aop"},{"content":"〇、IOC控制反转 把对象创建和对象之间的调用交给Spring进行管理，降低耦合度。\nxml解析、工厂模式、反射。\n一、Bean（使用xml） 1.0、使用Bean创建对象 1.0.0、准备对象 public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public User() {} public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); User user = (User) classPathXmlApplicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user); } } 1.0.1、使用无参构造和setter方法 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.0.2、使用有参构造方法 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.0.3、使用p \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34; p:name=\u0026#34;Jin\u0026#34; p:age=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 1.0.4、设置空值 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;null/\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.1、注入 准备对象 public class UserService { private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } @Override public String toString() { return \u0026#34;UserService{\u0026#34; + \u0026#34;user=\u0026#34; + user + \u0026#39;}\u0026#39;; } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); UserService userService = (UserService) classPathXmlApplicationContext.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;life.jinjiang.UserService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; ref=\u0026#34;user\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;life.jinjiang.UserService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; ref=\u0026#34;user\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user.name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;user.age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;life.jinjiang.UserService\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 1.2、作用域 单实例：singleton默认，读取配置文件时就创建\n多实例：prototype，创建对象时才创建\npublic class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); User user = (User) classPathXmlApplicationContext.getBean(\u0026#34;user\u0026#34;); User user2 = (User) classPathXmlApplicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user==user2); } } 默认单实例输出true\n更改配置文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 多实例输出false\n1.3、生命周期 public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; System.out.println(\u0026#34;执行setter方法\u0026#34;); } public User() { System.out.println(\u0026#34;执行构造方法\u0026#34;); } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } public void initMethod() { System.out.println(\u0026#34;执行init方法\u0026#34;); } public void destroyMethod() { System.out.println(\u0026#34;执行destroy方法\u0026#34;); } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); User user = (User) classPathXmlApplicationContext.getBean(\u0026#34;user\u0026#34;); classPathXmlApplicationContext.close(); } } 输出\n执行构造方法 执行setter方法 执行init方法 执行destroy方法 后置处理器 public class MyBeanPost implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;执行postProcessBeforeInitialization方法\u0026#34;); return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName); } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;执行postProcessAfterInitialization方法\u0026#34;); return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34; init-method=\u0026#34;initMethod\u0026#34; destroy-method=\u0026#34;destroyMethod\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;myBeanPost\u0026#34; class=\u0026#34;life.jinjiang.MyBeanPost\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 执行构造方法 执行setter方法 执行postProcessBeforeInitialization方法 执行init方法 执行postProcessAfterInitialization方法 执行destroy方法 1.4、自动装配 autowire属性有两种常用的值：ByName和ByType\nByName：根据对象名称来匹配\nByType：根据对象类型来匹配\npublic class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public User() {} public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } public class UserService { private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } @Override public String toString() { return \u0026#34;UserService{\u0026#34; + \u0026#34;user=\u0026#34; + user + \u0026#39;}\u0026#39;; } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;life.jinjiang.User\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jin\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;life.jinjiang.UserService\u0026#34; autowire=\u0026#34;byName\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); UserService userService = (UserService) classPathXmlApplicationContext.getBean(\u0026#34;userService\u0026#34;); System.out.println(userService); } } 二、Bean（使用注解） 2.0、使用Bean创建对象 注解有四种\n@Component：\n@Service：\n@Controller：\n@Repository：\n功能都一样\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;life.jinjiang\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; import org.springframework.stereotype.Component; @Component public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public User() {} public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); User user = (User) classPathXmlApplicationContext.getBean(\u0026#34;user\u0026#34;); System.out.println(user); } } 2.1、组件扫描配置 扫描life.jinjiang下的所有包和子包\n\u0026lt;context:component-scan base-package=\u0026#34;life.jinjiang\u0026#34;/\u0026gt; 只扫描life.jinjiang下的@Component注解标注的类\n\u0026lt;context:component-scan base-package=\u0026#34;life.jinjiang\u0026#34; use-default-filters=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Component\u0026#34;/\u0026gt; \u0026lt;/context:component-scan\u0026gt; 扫描life.jinjiang下的除了@Controller下的包\n\u0026lt;context:component-scan base-package=\u0026#34;life.jinjiang\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt; \u0026lt;/context:component-scan\u0026gt; 2.2、注入 2.2.0、@Autowired @Autowired根据类型自动注入\n@Service public class UserService { @Autowired private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } @Override public String toString() { return \u0026#34;UserService{\u0026#34; + \u0026#34;user=\u0026#34; + user + \u0026#39;}\u0026#39;; } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.xml\u0026#34;); UserService userService = (UserService) classPathXmlApplicationContext.getBean(UserService.class); System.out.println(userService); } } 2.2.1、@Qualifier @Qualifier和@Autowired一起使用，根据属性名称自动注入\n在下面情况中只使用@Autowired会出错，因为User的实现有两个类，应该明确具体的类。\npublic interface User { void add(); } @Component public class UserImpl implements User { private String name; private int age; public UserImpl(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public UserImpl() {} public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } @Override public void add() { System.out.println(\u0026#34;add\u0026#34;); } } @Component public class UserImpl2 implements User{ @Override public void add() { System.out.println(\u0026#34;add\u0026#34;); } } @Service public class UserService { @Autowired private User user; public User getUser() { return user; } public void setUser(UserImpl user) { this.user = user; } @Override public String toString() { return \u0026#34;UserService{\u0026#34; + \u0026#34;user=\u0026#34; + user + \u0026#39;}\u0026#39;; } } nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type \u0026#39;life.jinjiang.User\u0026#39; available: expected single matching bean but found 2: userImpl,userImpl2 在@Autowired下添加@Qualifier(\u0026quot;userImpl\u0026quot;)可指定userImpl类\n@Service public class UserService { @Autowired @Qualifier(\u0026#34;userImpl\u0026#34;) private User user; public User getUser() { return user; } public void setUser(UserImpl user) { this.user = user; } @Override public String toString() { return \u0026#34;UserService{\u0026#34; + \u0026#34;user=\u0026#34; + user + \u0026#39;}\u0026#39;; } } 2.2.2、@Value @Value可以注入值\n@Value(\u0026#34;Jin\u0026#34;) private String name; @Value(\u0026#34;18\u0026#34;) private int age; 2.3、完全注解 不使用xml配置文件\n创建一个配置类\n@Configuration @ComponentScan(\u0026#34;life.jinjiang\u0026#34;) public class MyConfig { } public class MainApplication { public static void main(String[] args) { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class); UserService userService = (UserService) applicationContext.getBean(UserService.class); System.out.println(userService); } } ","permalink":"https://jinjiang.life/posts/spring-bean/","summary":"〇、IOC控制反转 把对象创建和对象之间的调用交给Spring进行管理，降低耦合度。\nxml解析、工厂模式、反射。\n一、Bean（使用xml） 1.0、使用Bean创建对象 1.0.0、准备对象 public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public User() {} public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } public class MainApplication { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\u0026#34;Bean.","title":"Spring Bean"},{"content":"JAVA内置注解 1、@Override注解 @Override注解在重写父类方法时使用。\n@Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } @Deprecated注解表示已弃用\n@Deprecated public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } @SuppressWarnings(\u0026quot;all\u0026quot;)表示忽略所有警告\n@SuppressWarnings(\u0026#34;all\u0026#34;) public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 自定义注解和使用自定义注解 public @interface MyAnno {} @MyAnno public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 自定义注解的属性 注解的属性类型限制：基本数据类型、String、枚举、注解、和前面类型的数组。\nenum Person { P1, P2 } public @interface MyAnno { String name(); int age(); Person per(); MyAnno2 an(); String[] str(); } @MyAnno(name=\u0026#34;jin\u0026#34;, age = 18, per = Person.P1, an = @MyAnno2, str = {\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;}) public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 注解可以使用默认值\npublic @interface MyAnno { String name(); int age() default 18; } @MyAnno(name=\u0026#34;jin\u0026#34;) public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 如果属性只有一个value则可以省略\npublic @interface MyAnno { String value(); } @MyAnno(\u0026#34;jin\u0026#34;) public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 自定义注解的元注解 1、@Target元注解表示注解生效的位置 ElementType.TYPE在类上生效\nElementType.METHOD在方法上生效\nElementType.FIELD在成员变量上生效\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}) public @interface MyAnno { String value(); } 2、@Retention元注解表示注解保留的阶段 RetentionPolicy.SOURCE源码阶段\nRetentionPolicy.CLASS字节码阶段\nRetentionPolicy.RUNTIME运行时阶段\n3、@Documented元注解表示注解是否提取到API文档 4、@Inherited元注解表示注解是否被子类继承 解析注解 Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnno { String className(); String methodName(); } public static void run(Class\u0026lt;MainApplication\u0026gt; mainApplicationClass) throws Exception { MyAnno annotation = mainApplicationClass.getAnnotation(MyAnno.class); String className = annotation.className(); String methodName = annotation.methodName(); Class cls = Class.forName(className); Constructor constructor = cls.getConstructor(); Object obj = constructor.newInstance(); Method method = cls.getMethod(methodName); method.invoke(obj); } @MyAnno(className = \u0026#34;com.jin.learnjava.User\u0026#34;, methodName = \u0026#34;eat\u0026#34;) public class MainApplication { public static void main(String[] args) throws Exception { Runner.run(MainApplication.class); } } ","permalink":"https://jinjiang.life/posts/java-02/","summary":"JAVA内置注解 1、@Override注解 @Override注解在重写父类方法时使用。\n@Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } @Deprecated注解表示已弃用\n@Deprecated public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } @SuppressWarnings(\u0026quot;all\u0026quot;)表示忽略所有警告\n@SuppressWarnings(\u0026#34;all\u0026#34;) public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 自定义注解和使用自定义注解 public @interface MyAnno {} @MyAnno public void eat() { System.out.println(\u0026#34;eating...\u0026#34;); } 自定义注解的属性 注解的属性类型限制：基本数据类型、String、枚举、注解、和前面类型的数组。\nenum Person { P1, P2 } public @interface MyAnno { String name(); int age(); Person per(); MyAnno2 an(); String[] str(); } @MyAnno(name=\u0026#34;jin\u0026#34;, age = 18, per = Person.","title":"Java 注解"},{"content":"准备 定义一个User类\npublic class User { private String name; private int id; public User(String name, int id) { this.name = name; this.id = id; } public User() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } } Class类 获取Class类的三种方法 1、使用Class.forName()方法 Class c1 = Class.forName(\u0026#34;life.jinjiang.User\u0026#34;); 2、使用类名.class方法 Class c2 = User.class; 3、使用对象.getClass()方法 User user1 = new User(); Class c3 = user1.getClass(); 使用Class类获取类的成员变量 1、使用getFields()获取所有的public成员变量 Class c1 = User.class; Field[] fields = c1.getFields(); for(Field field : fields) { System.out.Println(field); } 2、使用getField()获取指定的public成员变量 Class c1 = User.class; Field field = c1.getField(\u0026#34;name\u0026#34;); 3、使用getDeclaredFields()获取所有的成员变量 Class c1 = User.class; Field[] fields = c1.getDeclaredFields(); for(Field field : fields) { System.out.Println(field); } 4、使用getDeclaredField()获取指定的成员变量 Class c1 = User.class; Field field = c1.getDeclaredField(\u0026#34;name\u0026#34;); 5、获取和设置成员变量的值 User user1 = new User(); Class c1 = User.class; Field name = c1.getDeclaredField(\u0026#34;name\u0026#34;); name.setAccessible(true);//不检测可见性 System.out.println(name.get(user1)); name.set(user1, \u0026#34;jin\u0026#34;); System.out.println(user1.getName()); 使用Class类获取类的构造方法 Class c1 = User.class; Constructor constructor = c1.getConstructor(String.class, int.class); Object user1 = constructor.newInstance(\u0026#34;jin\u0026#34;, 1); System.out.println(user1); Class c1 = User.class; Constructor constructor = c1.getDeclaredConstructor(String.class); constructor.setAccessible(true); Object user1 = constructor.newInstance(\u0026#34;jin\u0026#34;); System.out.println(user1); 使用Class类获取类的成员方法 Class c1 = User.class; User user1 = new User(\u0026#34;jin\u0026#34;, 1); Method getName = c1.getMethod(\u0026#34;getName\u0026#34;); Object str = getName.invoke(user1); System.out.println(str); 反射的使用 ClassLoader classLoader = MainApplication.class.getClassLoader(); InputStream inputStream = classLoader.getResourceAsStream(\u0026#34;pro.properties\u0026#34;); Properties pro = new Properties(); pro.load(inputStream); String className = pro.getProperty(\u0026#34;className\u0026#34;); String methodName = pro.getProperty(\u0026#34;methodName\u0026#34;); Class cls = Class.forName(className); Constructor constructor = cls.getConstructor(); Object obj = constructor.newInstance(); Method method = cls.getMethod(methodName); method.invoke(obj); className = com.jin.learnjava.User methodName = eat ","permalink":"https://jinjiang.life/posts/java-01/","summary":"准备 定义一个User类\npublic class User { private String name; private int id; public User(String name, int id) { this.name = name; this.id = id; } public User() { } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, id=\u0026#34; + id + \u0026#39;}\u0026#39;; } } Class类 获取Class类的三种方法 1、使用Class.","title":"Java 反射"},{"content":"线程 使用spawn创建新线程\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } } 程序会输出\nhi number 1 from the main thread! hi number 1 from the spawned thread! hi number 2 from the main thread! hi number 2 from the spawned thread! hi number 3 from the main thread! hi number 3 from the spawned thread! hi number 4 from the main thread! hi number 4 from the spawned thread! hi number 5 from the spawned thread! 这里spawn的线程到4就结束了，因为main线程提前结束了\n使用join等待所有线程结束 use std::thread; use std::time::Duration; fn main() { let handle = thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } handle.join().unwrap(); } 大致会产生如下输出\nhi number 1 from the main thread! hi number 2 from the main thread! hi number 1 from the spawned thread! hi number 3 from the main thread! hi number 2 from the spawned thread! hi number 4 from the main thread! hi number 3 from the spawned thread! hi number 4 from the spawned thread! hi number 5 from the spawned thread! hi number 6 from the spawned thread! hi number 7 from the spawned thread! hi number 8 from the spawned thread! hi number 9 from the spawned thread! 线程与move闭包 闭包可以使用环境中的变量\n下面代码无法编译，因为不知道v是否一直有效\nuse std::thread; fn main() { let v = vec![1, 2, 3]; let handle = thread::spawn(|| { println!(\u0026#34;Here\u0026#39;s a vector: {:?}\u0026#34;, v); }); handle.join().unwrap(); } 可以使用move获取v的所有权来解决，保证v不会在线程结束前失效\nuse std::thread; fn main() { let v = vec![1, 2, 3]; let handle = thread::spawn(move || { println!(\u0026#34;Here\u0026#39;s a vector: {:?}\u0026#34;, v); }); handle.join().unwrap(); } 消息传递 rust是通过通道来传递消息的，通道有两部分组成，一部分是发送者，一部分是接收者\n创建通道\nuse std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel();//返回一个元组，tx是发送者，rx是接收者 } 发送消息 use std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); }); } 接收消息 接收消息有两种方式，recv和try_recv，recv会阻塞线程，而try_recv不会\nuse std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); }); let received = rx.recv().unwrap(); println!(\u0026#34;Got: {}\u0026#34;, received); } 程序会输出\nGot: hi 通道与所有权转移 发送消息后所有权就没有了，再使用变量会出错\nuse std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); thread::spawn(move || { let val = String::from(\u0026#34;hi\u0026#34;); tx.send(val).unwrap(); println!(\u0026#34;val is {}\u0026#34;, val);//错误 }); let received = rx.recv().unwrap(); println!(\u0026#34;Got: {}\u0026#34;, received); } 通过克隆发送者来创建多个生产者 use std::thread; use std::sync::mpsc; fn main() { let (tx, rx) = mpsc::channel(); let tx1 = tx.clone(); thread::spawn(move || { let vals = vec![ String::from(\u0026#34;hi\u0026#34;), String::from(\u0026#34;from\u0026#34;), String::from(\u0026#34;the\u0026#34;), String::from(\u0026#34;thread\u0026#34;), ]; for val in vals { tx1.send(val).unwrap(); thread::sleep(Duration::from_secs(1)); } }); thread::spawn(move || { let vals = vec![ String::from(\u0026#34;more\u0026#34;), String::from(\u0026#34;messages\u0026#34;), String::from(\u0026#34;for\u0026#34;), String::from(\u0026#34;you\u0026#34;), ]; for val in vals { tx.send(val).unwrap(); thread::sleep(Duration::from_secs(1)); } }); for received in rx { println!(\u0026#34;Got: {}\u0026#34;, received); } } 共享状态 互斥器 互斥器在任何时候，只允许一个线程访问，为了访问互斥器中的数据，线程首先需要通过获取互斥器的锁\n在单线程上下文使用互斥器\nuse std::sync::Mutex; fn main() { let m = Mutex::new(5); { let mut num = m.lock().unwrap(); *num = 6; } println!(\u0026#34;m = {:?}\u0026#34;, m);//输出6 } 使用lock()来获取锁，当一个线程获取锁后，其他线程就无法在获取了，会产生panic\n在线程间共享Mutex\u0026lt;T\u0026gt; 尝试使用mutex在多个线程间共享值\nuse std::sync::Mutex; use std::thread; fn main() { let counter = Mutex::new(0); let mut handles = vec![]; for _ in 0..10 { let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap();//等待每个线程结束 } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 会出现如下错误\nerror[E0382]: use of moved value: `counter` --\u0026gt; smart_pointers/src/main.rs:9:36 | 5 | let counter = Mutex::new(0); | ------- move occurs because `counter` has type `Mutex\u0026lt;i32\u0026gt;`, which does not implement the `Copy` trait ... 9 | let handle = thread::spawn(move || { | ^^^^^^^ value moved into closure here, in previous iteration of loop 10 | let mut num = counter.lock().unwrap(); | ------- use occurs due to use in closure 编译器告诉我们counter被移动了，不能在多个线程中使用\n那如果使用之前的Rc\u0026lt;T\u0026gt;来创建引用计数的值，以便拥有多个所有者\nuse std::rc::Rc; use std::sync::Mutex; use std::thread; fn main() { let counter = Rc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Rc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap(); } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 不幸的是这样也不行，编译器会告诉你不安全\n不过还有一种Arc\u0026lt;T\u0026gt;可以安全的实现这个功能\nuse std::sync::{Mutex, Arc}; use std::thread; use std::rc::Rc; fn main() { let counter = Arc::new(Mutex::new(0)); let mut handles = vec![]; for _ in 0..10 { let counter = Arc::clone(\u0026amp;counter); let handle = thread::spawn(move || { let mut num = counter.lock().unwrap(); *num += 1; }); handles.push(handle); } for handle in handles { handle.join().unwrap();//等待每个线程结束 } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); } 程序终于能够成功运行，并输出如下内容\nResult: 10 使用Sync和Send trait的可扩展并发\n","permalink":"https://jinjiang.life/posts/rust-11/","summary":"线程 使用spawn创建新线程\nuse std::thread; use std::time::Duration; fn main() { thread::spawn(|| { for i in 1..10 { println!(\u0026#34;hi number {} from the spawned thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } }); for i in 1..5 { println!(\u0026#34;hi number {} from the main thread!\u0026#34;, i); thread::sleep(Duration::from_millis(1)); } } 程序会输出\nhi number 1 from the main thread! hi number 1 from the spawned thread! hi number 2 from the main thread! hi number 2 from the spawned thread!","title":"Rust并发"},{"content":"使用Box\u0026lt;T\u0026gt;指向堆上的数据 使用box在堆上储存一个i32\nb是一个指向被分配在堆上的值5的Box\nfn main() { let b = Box::new(5); println!(\u0026#34;b = {}\u0026#34;, b); } 用Box\u0026lt;T\u0026gt;可以实现类似链表的结构\n#[derive(Debug)] enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); println!(\u0026#34;{:?}\u0026#34;, list) } 通过Deref trait将智能指针当作常规引用处理 通过解引用运算符追踪指针的值 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, *y); } 如果使用下面的代码则会出错\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, y); } 不允许比较数字的引用与数字，因为它们是不同的类型。必须使用解引用运算符追踪引用所指向的值。\n像引用一样使用Box\u0026lt;T\u0026gt; fn main() { let x = 5; let y = Box::new(x); assert_eq!(5, x); assert_eq!(5, *y); } 自定义智能指针 #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } fn main() { let a = 5; let b = MyBox::new(a); assert_eq!(5, a); assert_eq!(5, *b); } 这里我们定义了一个智能指针MyBox，并尝试使用Box的解引用方法，但是会出错，因为rust不知道怎么解引用MyBox，需要实现deref方法才行\nuse std::ops::Deref; #[derive(Debug)] struct MyBox\u0026lt;T\u0026gt;(T); impl\u0026lt;T\u0026gt; MyBox\u0026lt;T\u0026gt; { fn new(x: T) -\u0026gt; MyBox\u0026lt;T\u0026gt; { MyBox(x) } } impl\u0026lt;T\u0026gt; Deref for MyBox\u0026lt;T\u0026gt; { type Target = T; fn deref(\u0026amp;self) -\u0026gt; \u0026amp;Self::Target { \u0026amp;self.0 } } fn main() { let a = 5; let b = MyBox::new(a); assert_eq!(5, a); assert_eq!(5, *b); } 函数和方法的隐式解引用强制多态 解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 \u0026amp; 和 * 的引用和解引用。\n如下面代码\nfn main() { let m = Box::new(String::from(\u0026#34;murphy\u0026#34;)); hello(\u0026amp;(*m)); } fn hello(name: \u0026amp;str) { println!(\u0026#34;hello, {}\u0026#34;, name); } 可以直接写成\nfn main() { let m = Box::new(String::from(\u0026#34;murphy\u0026#34;)); hello(\u0026amp;m); } fn hello(name: \u0026amp;str) { println!(\u0026#34;hello, {}\u0026#34;, name); } 使用Drop Trait运行清理代码 Rc\u0026lt;T\u0026gt;引用计数智能指针 大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值。然而，有些情况单个值可能会有多个所有者。例如，在图数据结构中，多个边可能指向相同的节点，而这个节点从概念上讲为所有指向它的边所拥有。节点直到没有任何边指向它之前都不应该被清理。\n使用Rc\u0026lt;T\u0026gt;共享数据 如下代码是无法运行的，因为a的所有权已经移动给b了\nfn main() { let a = Box::new(String::from(\u0026#34;hello, world\u0026#34;)); let b = Box::new(a); let c = Box::new(a); println!(\u0026#34;{},{}\u0026#34;, b, c) } 如果要有多个所有者就要使用引用计数Rc\u0026lt;T\u0026gt;\nuse std::rc::Rc; fn main() { let a = Rc::new(String::from(\u0026#34;hello, world\u0026#34;)); let b = Rc::clone(\u0026amp;a); let c = Rc::clone(\u0026amp;a); println!(\u0026#34;b:{},c:{}\u0026#34;, b, c) } RefCell\u0026lt;T\u0026gt;和内部可变性模式 ","permalink":"https://jinjiang.life/posts/rust-10/","summary":"使用Box\u0026lt;T\u0026gt;指向堆上的数据 使用box在堆上储存一个i32\nb是一个指向被分配在堆上的值5的Box\nfn main() { let b = Box::new(5); println!(\u0026#34;b = {}\u0026#34;, b); } 用Box\u0026lt;T\u0026gt;可以实现类似链表的结构\n#[derive(Debug)] enum List { Cons(i32, Box\u0026lt;List\u0026gt;), Nil, } use crate::List::{Cons, Nil}; fn main() { let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil)))))); println!(\u0026#34;{:?}\u0026#34;, list) } 通过Deref trait将智能指针当作常规引用处理 通过解引用运算符追踪指针的值 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, *y); } 如果使用下面的代码则会出错\nfn main() { let x = 5; let y = \u0026amp;x; assert_eq!","title":"Rust智能指针"},{"content":"闭包：可以捕获环境的匿名函数 Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。\n使用闭包创建行为的抽象 use std::thread; use std::time::Duration; fn simulated_expensive_calculation(intensity: u32) -\u0026gt; u32 { println!(\u0026#34;calculating slowly...\u0026#34;); thread::sleep(Duration::from_secs(2)); intensity } ","permalink":"https://jinjiang.life/posts/rust-09/","summary":"闭包：可以捕获环境的匿名函数 Rust 的 闭包（closures）是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。\n使用闭包创建行为的抽象 use std::thread; use std::time::Duration; fn simulated_expensive_calculation(intensity: u32) -\u0026gt; u32 { println!(\u0026#34;calculating slowly...\u0026#34;); thread::sleep(Duration::from_secs(2)); intensity } ","title":"Rust迭代器与闭包"},{"content":"编写测试 先创建一个新的库项目\ncargo new adder --lib 会自动生成src/lib.rs\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } ","permalink":"https://jinjiang.life/posts/rust-08/","summary":"编写测试 先创建一个新的库项目\ncargo new adder --lib 会自动生成src/lib.rs\n#[cfg(test)] mod tests { #[test] fn it_works() { assert_eq!(2 + 2, 4); } } ","title":"Rust测试"},{"content":"泛型数据类型 在函数定义中使用泛型\n下面代码有两个函数，找出最大的数字和字母的\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;number_list); println!(\u0026#34;The largest number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest_char(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 这两个函数实现的功能都是一样的\n所以可以使用泛型来把他们整合到一起\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;number_list); println!(\u0026#34;The largest number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 结构体中的泛型\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } fn main() { let integer = Point { x: 5, y: 10 }; let float = Point { x: 1.0, y: 4.0 }; } 下面代码是错误的，类型都是T说明xy类型一样\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } fn main() { let wont_work = Point { x: 5, y: 4.0 }; } struct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } fn main() { let both_integer = Point { x: 5, y: 10 }; let both_float = Point { x: 1.0, y: 4.0 }; let integer_and_float = Point { x: 5, y: 4.0 }; } 枚举定义中的泛型\nenum Option\u0026lt;T\u0026gt; { Some(T), None, } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } 方法定义中的泛型\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } fn main() { let p = Point { x: 5, y: 10 }; println!(\u0026#34;p.x = {}\u0026#34;, p.x()); } struct Point\u0026lt;T, U\u0026gt; { x: T, y: U, } impl\u0026lt;T, U\u0026gt; Point\u0026lt;T, U\u0026gt; { fn mixup\u0026lt;V, W\u0026gt;(self, other: Point\u0026lt;V, W\u0026gt;) -\u0026gt; Point\u0026lt;T, W\u0026gt; { Point { x: self.x, y: other.y, } } } fn main() { let p1 = Point { x: 5, y: 10.4 }; let p2 = Point { x: \u0026#34;Hello\u0026#34;, y: \u0026#39;c\u0026#39;}; let p3 = p1.mixup(p2); println!(\u0026#34;p3.x = {}, p3.y = {}\u0026#34;, p3.x, p3.y); } 还可以只对一种类型提供方法\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn get_x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } impl Point\u0026lt;String\u0026gt; { fn x_add(\u0026amp;mut self, str: \u0026amp;String) { self.x = format!(\u0026#34;{}{}\u0026#34;, self.x, str) } } fn main() { let a1 = Point { x: 5, y: 10 }; println!(\u0026#34;{}\u0026#34;, a1.get_x()); let mut a2 = Point { x: String::from(\u0026#34;Hello\u0026#34;), y: String::from(\u0026#34;world\u0026#34;) }; let str = String::from(\u0026#34;world\u0026#34;); a2.x_add(\u0026amp;str); println!(\u0026#34;{}\u0026#34;, a2.get_x()); } trait:定义共享的行为 trait类似于其他语言的接口功能\n定义trait\n","permalink":"https://jinjiang.life/posts/rust-07/","summary":"泛型数据类型 在函数定义中使用泛型\n下面代码有两个函数，找出最大的数字和字母的\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let number_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;number_list); println!","title":"Rust泛型、trait与生命周期"},{"content":"panic!与不可恢复的错误 调用panic!\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } Result与可恢复的错误 use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, error) }, }; } 匹配不同的错误\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026#34;hello.txt\u0026#34;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!(\u0026#34;Problem creating the file: {:?}\u0026#34;, e), }, other_error =\u0026gt; panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, other_error), }, }; } 失败时panic的简写\nuse std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;).unwrap(); } use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;).expect(\u0026#34;Failed to open hello.txt\u0026#34;); } 传播错误\nuse std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let f = File::open(\u0026#34;hello.txt\u0026#34;); let mut f = match f { Ok(file) =\u0026gt; file, Err(e) =\u0026gt; return Err(e), }; let mut s = String::new(); match f.read_to_string(\u0026amp;mut s) { Ok(_) =\u0026gt; Ok(s), Err(e) =\u0026gt; Err(e), } } 传播错误的简写\nuse std::io; use std::io::Read; use std::fs::File; fn read_username_from_file() -\u0026gt; Result\u0026lt;String, io::Error\u0026gt; { let mut f = File::open(\u0026#34;hello.txt\u0026#34;)?; let mut s = String::new(); f.read_to_string(\u0026amp;mut s)?; Ok(s) } ","permalink":"https://jinjiang.life/posts/rust-06/","summary":"panic!与不可恢复的错误 调用panic!\nfn main() { panic!(\u0026#34;crash and burn\u0026#34;); } Result与可恢复的错误 use std::fs::File; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; { panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;, error) }, }; } 匹配不同的错误\nuse std::fs::File; use std::io::ErrorKind; fn main() { let f = File::open(\u0026#34;hello.txt\u0026#34;); let f = match f { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; match error.kind() { ErrorKind::NotFound =\u0026gt; match File::create(\u0026#34;hello.txt\u0026#34;) { Ok(fc) =\u0026gt; fc, Err(e) =\u0026gt; panic!","title":"Rust错误处理"},{"content":"vector vector在内存中是连续的，只能存储相同类型的值\n新建vector\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); 或者使用rust提供的vec!宏来新建一个vector\nlet v = vec![1, 2, 3]; 更新vector\nlet mut v = Vec::new();//需要可变才能改变 v.push(5); 读取vector的元素\nlet v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is {}\u0026#34;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026#34;The third element is {}\u0026#34;, third), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } 下面代码会报错\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.push(6);//加入一个元素会使v重新分配一块连续的地址，所以原来的引用就无效了，rust不允许无效引用 println!(\u0026#34;The first element is: {}\u0026#34;, first); 遍历vector\nlet v = vec![1, 2, 3, 4, 5]; for i in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, i); } 使用枚举来存储多种类型\nvector只能存储一种类型，而枚举算一种类型，可以用枚举来存储多种类型\n#![allow(unused)] fn main() { enum SpreadsheetCell { Int(i32), Float(f64), Text(String), } let row = vec![ SpreadsheetCell::Int(3), SpreadsheetCell::Text(String::from(\u0026#34;blue\u0026#34;)), SpreadsheetCell::Float(10.12), ]; } 字符串 新建字符串\nlet mut s = String::new();//新建空字符串 let s = \u0026#34;initial contents\u0026#34;.to_string();//用to_string新建字符串 let s = String::from(\u0026#34;initial contents\u0026#34;);//用from新建字符串 更新字符串\nlet mut s = String::from(\u0026#34;hello\u0026#34;); s.push_str(\u0026#34;world\u0026#34;);//将字符串添加到string s.push(\u0026#39;!\u0026#39;);//将字符添加到string 使用+或format!拼接字符串\nlet s1 = String::from(\u0026#34;Hello,\u0026#34;); let s2 = String::from(\u0026#34;world!\u0026#34;); let s3 = s1 + \u0026amp;s2;//s1 被移动了，不能继续使用 let s1 = String::from(\u0026#34;tic\u0026#34;); let s2 = String::from(\u0026#34;tac\u0026#34;); let s3 = String::from(\u0026#34;toe\u0026#34;); let s = format!(\u0026#34;{}-{}-{}\u0026#34;, s1, s2, s3);//会获取任何参数的所有权 遍历字符串\nfor c in \u0026#34;你好，世界\u0026#34;.chars() { println!(\u0026#34;{}\u0026#34;, c); } 哈希map键值对 新建一个哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); 哈希map所有的键必须是相同类型，所有的值也必须是相同类型\n也可以使用下面的方法构建一个哈希map\nuse std::collections::HashMap; let teams = vec![String::from(\u0026#34;Blue\u0026#34;), String::from(\u0026#34;Yellow\u0026#34;)]; let initial_scores = vec![10, 50]; let scores: HashMap\u0026lt;_, _\u0026gt; = teams.iter().zip(initial_scores.iter()).collect(); 访问哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); let team_name = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_name); 遍历哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); for (key, value) in \u0026amp;scores { println!(\u0026#34;{}: {}\u0026#34;, key, value); } 更新哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 25); println!(\u0026#34;{:?}\u0026#34;, scores); 在没有值时更新哈希map\nuse std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.entry(String::from(\u0026#34;Yellow\u0026#34;)).or_insert(50); scores.entry(String::from(\u0026#34;Blue\u0026#34;)).or_insert(50); println!(\u0026#34;{:?}\u0026#34;, scores); ","permalink":"https://jinjiang.life/posts/rust-05/","summary":"vector vector在内存中是连续的，只能存储相同类型的值\n新建vector\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); 或者使用rust提供的vec!宏来新建一个vector\nlet v = vec![1, 2, 3]; 更新vector\nlet mut v = Vec::new();//需要可变才能改变 v.push(5); 读取vector的元素\nlet v = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2]; println!(\u0026#34;The third element is {}\u0026#34;, third); match v.get(2) { Some(third) =\u0026gt; println!(\u0026#34;The third element is {}\u0026#34;, third), None =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;), } 下面代码会报错\nlet mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0]; v.","title":"Rust集合"},{"content":"枚举 定义枚举\nenum IpAddrKind { V4, V6, } 枚举值\nlet four = IpAddrKind::V4; let six = IpAddrKind::V6; 他们的类型都是IpAddrKind\n如函数：\nfn rout(ip_type: IpAddrKind) { } 可以向下面一样调用\nroute(IpAddrKind::V4); route(IpAddrKind::V6); match控制流运算符 enum Coin { Penny, Nickel, Dime, Quarter, } let a = Coin::Penny; let b = match a { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, }; println!(\u0026#34;{}\u0026#34;, b); let c = match a { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); 1 }, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, } 绑定值的模式\n可以用来获取枚举绑定的值\nenum Ip { V4(u8, u8, u8, u8), V6(String), } fn print_ip(ip: \u0026amp;Ip) { match ip { Ip::V4(a, b, c, d) =\u0026gt; println!(\u0026#34;{}.{}.{}.{}\u0026#34;, a, b, c, d), Ip::V6(a) =\u0026gt; println!(\u0026#34;{}\u0026#34;, a), } } fn main() { let ip4 = Ip::V4(127, 0, 0, 1); let ip6 = Ip::V6(String::from(\u0026#34;::1\u0026#34;)); print_ip(\u0026amp;ip4); print_ip(\u0026amp;ip6); } 通配符\nrust的match必须列出所有可能，有时候只需要几个匹配，其他的可以用通配符_来匹配\nlet some_u8_value = 0u8; match some_u8_value { 1 =\u0026gt; println!(\u0026#34;one\u0026#34;), 3 =\u0026gt; println!(\u0026#34;three\u0026#34;), 5 =\u0026gt; println!(\u0026#34;five\u0026#34;), 7 =\u0026gt; println!(\u0026#34;seven\u0026#34;), _ =\u0026gt; (), } ","permalink":"https://jinjiang.life/posts/rust-04/","summary":"枚举 定义枚举\nenum IpAddrKind { V4, V6, } 枚举值\nlet four = IpAddrKind::V4; let six = IpAddrKind::V6; 他们的类型都是IpAddrKind\n如函数：\nfn rout(ip_type: IpAddrKind) { } 可以向下面一样调用\nroute(IpAddrKind::V4); route(IpAddrKind::V6); match控制流运算符 enum Coin { Penny, Nickel, Dime, Quarter, } let a = Coin::Penny; let b = match a { Coin::Penny =\u0026gt; 1, Coin::Nickel =\u0026gt; 5, Coin::Dime =\u0026gt; 10, Coin::Quarter =\u0026gt; 25, }; println!(\u0026#34;{}\u0026#34;, b); let c = match a { Coin::Penny =\u0026gt; { println!","title":"Rust枚举和模式匹配"},{"content":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例\nlet user2 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: user1.active, sign_in_count: user1.sign_in_count, }; 相同的部分可以简写\nlet user2 = User { email: String::from(\u0026#34;Murphy.W.Zhu1@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu1\u0026#34;), ..user1 }; 元组结构体 元组结构体相当于没有字段名的结构体\nstruct Color(i32, i32, i32); let mut black = Color(0, 1, 0); black.1 = 0;//可以使用.的方式访问 println!(\u0026#34;{},{},{}\u0026#34;, black.0,black.1,black.2); 在函数中使用结构体 结构体也是有所有权的，所以要借用\nstruct Rectangle { width: u32, height: u32, } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, area(\u0026amp;rect1) ); } fn area(rectangle: \u0026amp;Rectangle) -\u0026gt; u32 { rectangle.width * rectangle.height } 结构体方法 方法与函数类似，像其他面向对象的语言中一样，方法的第一个参数是self\n定义方法\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!( \u0026#34;The area of the rectangle is {} square pixels.\u0026#34;, rect1.area() ); } 带有更多参数的方法\nstruct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50 }; let rect2 = Rectangle { width: 10, height: 40 }; let rect3 = Rectangle { width: 60, height: 45 }; println!(\u0026#34;Can rect1 hold rect2? {}\u0026#34;, rect1.can_hold(\u0026amp;rect2)); println!(\u0026#34;Can rect1 hold rect3? {}\u0026#34;, rect1.can_hold(\u0026amp;rect3)); } 关联函数\n参数不包含self，关联函数经常被用作返回一个结构体新实例的构造函数。\nimpl Rectangle { fn square(size: u32) -\u0026gt; Rectangle { Rectangle { width: size, height: size } } } let sq = Rectangle::square(3); ","permalink":"https://jinjiang.life/posts/rust-03/","summary":"结构体 定义结构体\nstruct User { username: String, email: String, sign_in_count: u64, active: bool, } 创建结构体实例\nlet mut user1 = User { email: String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;), username: String::from(\u0026#34;Murphy.W.Zhu\u0026#34;), active: true, sign_in_count: 1, }; 改变实例属性\nuser1.email = String::from(\u0026#34;Murphy.W.Zhu@aliyun.com\u0026#34;); 返回结构体\nfn build_user(email: String, username: String) -\u0026gt; User { User { email: email, username: username, active: true, sign_in_count: 1, } } 变量与字段同名是的字段初始化简写语法\nfn build_user(email: String, username: String) -\u0026gt; User { User { email, username, active: true, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例","title":"Rust结构体"},{"content":" Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 然后生成静态网页\nhugo -d docs 上传到github\ngit add * git commit -m \u0026#34;first commit\u0026#34; git remote add origin git@github.com:MurphyWZhu/blog.git git push -u origin main 设置github\n配置网站\n下面是一些我的配置，可以根据需要修改\nbaseURL: https://murphywzhu.github.io/blog/ languageCode: zh-cn defaultContentLanguage: zh-cn title: 锦酱的博客 theme: \u0026#34;PaperMod\u0026#34; languages: zh-cn: languageName: \u0026#34;简体中文\u0026#34; weight: 1 menu: main: - name: Search url: search/ weight: 10 - name: Tags url: tags/ weight: 10 params: profileMode: enabled: true title: \u0026#34;锦酱\u0026#34; # optional default will be site title subtitle: \u0026#34;锦酱!又出Bug啦!\u0026#34; imageUrl: \u0026#34;https://mublog.oss-cn-beijing.aliyuncs.com/mutx.jpeg\u0026#34; # optional imageTitle: \u0026#34;图片被吃掉了哎!\u0026#34; # optional imageWidth: 120 # custom size imageHeight: 120 # custom size buttons: - name: 文章 url: \u0026#34;posts/\u0026#34; - name: Github url: \u0026#34;https://github.com/murphywzhu\u0026#34; outputs: home: - HTML - RSS - JSON # is necessary 然后生成并push到github上\nhugo -d docs git add * git commit -m \u0026#34;updates $(date)\u0026#34; git push -u origin main 也可以将这些步骤写成脚本\n#! /bin/bash hugo -d docs git add * git commit -m \u0026#34;updates $(date)\u0026#34; git push -u origin main 接下来就应该可以访问了\n","permalink":"https://jinjiang.life/posts/hugo-00/","summary":"Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. Hugo是一个静态网页框架，可以快速生成网页，并且拥有许多的主题\n安装Hugo 在archlinux中\nsudo pacman -S hugo 使用源码安装\n需要有git和go(\u0026gt;=1.11)\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended % hugo version hugo v0.82.0+extended linux/amd64 BuildDate=unknown 创建网站 先在github上新建一个项目\n然后新建一个hugo网站项目\nhugo new site blog -f yml 初始化git，并设置默认分支名为main\ngit init git branch -m main 设置主题，这里设置PaperMod主题","title":"使用Hugo在github上搭建博客"},{"content":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明 let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的 // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); 所有权与函数 以下程序会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : String) { println!(\u0026#34;{}\u0026#34;, str); } 说a已经被移动了\nerror[E0382]: borrow of moved value: `a` --\u0026gt; src/main.rs:4:20 | 2 | let a = String::from(\u0026#34;Hello\u0026#34;); | - move occurs because `a` has type `String`, which does not implement the `Copy` trait 3 | print_str(a); | - value moved here 4 | println!(\u0026#34;{}\u0026#34;, a); | ^ value borrowed here after move 这是因为啊的所有权被移动到了print_str函数里，函数结束所有权就消失了\n那应该怎么办呢，不用担心，函数返回值的时候也会返回所有权，我们只需要将原来的参数返回就行\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); let b = print_str(a); println!(\u0026#34;{}\u0026#34;, b); } fn print_str(str : String) -\u0026gt; String{ println!(\u0026#34;{}\u0026#34;, str); str } 也可以像下面一样，将要返回的东西和原来的参数一起返回，不过这样着实是有些麻烦，不过我们接下来的东西可以解决\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length) } 借用 像下面这样在类型前面加个\u0026amp;就是借用了，借用是不能改变值的。\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ println!(\u0026#34;{}\u0026#34;, str); } 以下程序就会报错\nfn main() { let a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;String){ str.push_str(\u0026#34;,World!\u0026#34;); } error[E0596]: cannot borrow `*str` as mutable, as it is behind a `\u0026amp;` reference --\u0026gt; src/main.rs:8:5 | 7 | fn print_str(str : \u0026amp;String){ | ------- help: consider changing this to be a mutable reference: `\u0026amp;mut String` 8 | str.push_str(\u0026#34;,World!\u0026#34;); | ^^^ `str` is a `\u0026amp;` reference, so the data it refers to cannot be borrowed as mutable 没错，也可以像可变变量一样加个mut变成可变引用\n以下程序会输出Hello,World!\n要可以引用的话，变量本身也需要可变\nfn main() { let mut a = String::from(\u0026#34;Hello\u0026#34;); print_str(\u0026amp;mut a); println!(\u0026#34;{}\u0026#34;, a); } fn print_str(str : \u0026amp;mut String){ str.push_str(\u0026#34;,World!\u0026#34;); } 在特定作用域中的特定数据只能有一个可变引用。这些代码会失败：\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:14 | 4 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 5 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here 可以理解为一个对象只能同时存在一个可用的引用\n以下代码就可以使用\nlet mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}\u0026#34;, r2); 因为r1在r2之后不再使用\n悬垂引用 Rust里的悬垂引用相当于其他语言里的悬垂指针，内存释放了，指针还在的意思\n以下程序会出现悬垂引用\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); \u0026amp;s } error[E0106]: missing lifetime specifier --\u0026gt; src/main.rs:5:16 | 5 | fn dangle() -\u0026gt; \u0026amp;String { | ^ expected named lifetime parameter | = help: this function\u0026#39;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the `\u0026#39;static` lifetime | 5 | fn dangle() -\u0026gt; \u0026amp;\u0026#39;static String { | ^^^^^^^^ 因为s的作用域在{}之间，出了作用域就被释放了，这样返回的引用就变成了悬垂引用 解决办法就是直接返回String\nfn no_dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } ","permalink":"https://jinjiang.life/posts/rust-02/","summary":"所有权 所有权是rust的核心之一\n它有如下规则\n1、Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。 2、值在任一时刻有且只有一个所有者。 3、当所有者（变量）离开作用域，这个值将被丢弃。 变量作用域 #![allow(unused)] fn main() { { // s 在这里无效, 它尚未声明 let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的 // 使用 s } // 此作用域已结束，s 不再有效 } String类型 之前的类型都是栈上的，现在需要一个堆上的类型，String就是我们需要的类型\nlet s = String::from(\u0026#34;hello\u0026#34;); 对于栈上的数据rust直接复制了\nlet x = 5; let y = x; 对于堆上的数据，rust将原来的内存给了之后的，而原来的就无效了\n如下代码会错误，因为s1无效了，所以发生了无效引用\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); 如果要复制String的数据可以使用clone\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!","title":"Rust所有权"},{"content":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议\n这就是因为rust变量默认是不可改变的，要改变的话需要声明他是可变的，就像他提示的那样\nfn main() { let mut a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 常量 rust变量默认不可变，那好像和常量一样，常量不光默认不能变，它总是不能变。常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\nconst MAX_POINTS: u32 = 100_000; 数据类型 声明 let x: i64 = 10; let x = 5.5; char类型 rust的char为四个字节，代表一个unicode标量值，所以可以使用emoji、中文字符等等\nlet c = \u0026#39;z\u0026#39;; let z = \u0026#39;ℤ\u0026#39;; let heart_eyed_cat = \u0026#39;😻\u0026#39;; 元组(tup) let tup: (i32, f64, u8) = (500, 6.4, 1); let tup = (500, 6.4, 1); println!(\u0026#34;{}\u0026#34;, tup.0); 元组默认也是不可变的，也需要加mut声明可变才可改变\nlet mut tup = (50, 6.1, 5); tup.0 = 55; 数组(array) 数组是固定长度的，一旦声明，它们的长度不能增长或缩小。\nlet a = [1, 2, 3, 4, 5]; let b: [i32; 5] = [1, 2, 3, 4, 5]; let c = [3; 5];//[3,3,3,3,3] println!(\u0026#34;{}\u0026#34;, a[0]); 数组同样也是不可变的啦，也要加mut才可改变\nlet mut list = [5, 5, 5, 5]; 函数 函数是面向过程的语言里非常重要的一个东西\n在rust里的函数的定义如下\nfn func_name(x: i32) -\u0026gt; i32 { x*2 } fn func_name(x: i32) -\u0026gt; i32 { return x*2 } rust函数的最后一条表达式的值当作返回值，也可以使用return返回\nrust里只有表达式才有值，函数调用也是表达式\n控制流 if表达式 if语句也是表达式所以也有值\n一下程序会输出20\nfn main() { let a = 10; let b = if a \u0026gt; 10 { a } else { a*2 }; println!(\u0026#34;{}\u0026#34;, b); } rust的if语句中的条件只能是值为bool型的表达式\nloop循环 fn main() { loop { println!(\u0026#34;again!\u0026#34;); } } 可以用break退出循环，loop表达式的值，即是break后面的表达式的值\n下面程序会输出20\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;The result is {}\u0026#34;, result); } while条件循环 fn main() { let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number = number - 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } for循环 fn main() { let a = [10, 20, 30, 40, 50]; for element in a.iter() { println!(\u0026#34;the value is: {}\u0026#34;, element); } } fn main() { for number in (1..4).rev() { println!(\u0026#34;{}!\u0026#34;, number); } println!(\u0026#34;LIFTOFF!!!\u0026#34;); } ","permalink":"https://jinjiang.life/posts/rust-01/","summary":"不变变量 以下程序理所当然的输出5\nfn main() { let a = 5; println!(\u0026#34;{}\u0026#34;, a); } 而当你尝试改变a的值时\nfn main() { let a = 5; a = 6; println!(\u0026#34;{}\u0026#34;, a); } 则会出现错误\nerror[E0384]: cannot assign twice to immutable variable `a` --\u0026gt; src/main.rs:3:5 | 2 | let a = 5; | - | | | first assignment to `a` | help: make this binding mutable: `mut a` 3 | a = 6; | ^^^^^ cannot assign twice to immutable variable rust会很人性化的提示你哪里错了，还会给出建议","title":"Rust常见编程概念"},{"content":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写\n","permalink":"https://jinjiang.life/posts/rust-00/","summary":"Rust 据官网说介绍rust是一门高性能，高可靠的编程语言，最主要的特点就是安全可靠，据悉Linux内核都在考虑是否用rust代替C\nRust安装 可以使用官方的rustup来安装rust以及其他工具\nsudo pacman -S rustup 设置rustup的下载源\nexport RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup 安装rust\nrustup install stable rustup component add rust-src Helloworld\nCode % cargo new hello-world Created binary (application) `hello-world` package Code % cd hello-world hello-world[master*] % ls Cargo.toml src hello-world[master*] % cargo run Compiling hello-world v0.1.0 (/home/murphy/Code/hello-world) Finished dev [unoptimized + debuginfo] target(s) in 1.15s Running `target/debug/hello-world` Hello, world! Rust IDE rust还没有官方的IDE，我使用Clion的rust插件来写","title":"Rust初试"}]